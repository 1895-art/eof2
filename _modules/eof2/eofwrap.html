
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>eof2.eofwrap &mdash; eof2 1.5.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/extension.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.5.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="eof2 1.5.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../index.html">eof2 1.5.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for eof2.eofwrap</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Meta-data preserving EOF analysis for :py:mod:`cdms2` variables.&quot;&quot;&quot;</span>
<span class="c"># (c) Copyright 2010-2012 Andrew Dawson. All Rights Reserved.</span>
<span class="c"># </span>
<span class="c"># This file is part of eof2.</span>
<span class="c"># </span>
<span class="c"># eof2 is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c"># </span>
<span class="c"># eof2 is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c"># FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c"># for more details.</span>
<span class="c"># </span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with eof2.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="kn">import</span> <span class="nn">cdms2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>

<span class="kn">from</span> <span class="nn">eofsolve</span> <span class="kn">import</span> <span class="n">EofSolver</span>
<span class="kn">from</span> <span class="nn">tools</span> <span class="kn">import</span> <span class="n">weights_array</span>
<span class="kn">from</span> <span class="nn">errors</span> <span class="kn">import</span> <span class="n">EofError</span><span class="p">,</span> <span class="n">EofToolError</span>


<div class="viewcode-block" id="Eof"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof">[docs]</a><span class="k">class</span> <span class="nc">Eof</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;EOF analysis (meta-data enabled :py:mod:`cdms2` interface).&quot;&quot;&quot;</span> 
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Eof object.</span>
<span class="sd">        </span>
<span class="sd">        **Argument:**</span>

<span class="sd">        *dataset*</span>
<span class="sd">            A :py:mod:`cdms2` variable containing the data to be</span>
<span class="sd">            analyzed. Time must be the first dimension. Missing values</span>
<span class="sd">            are allowed provided that they are constant with time (e.g.,</span>
<span class="sd">            values of an oceanographic field over land).</span>
<span class="sd">        </span>
<span class="sd">        **Optional arguments:**</span>

<span class="sd">        *weights*</span>
<span class="sd">            Sets the weighting method. The following values are</span>
<span class="sd">            accepted:</span>

<span class="sd">            * *&quot;area&quot;* : Square-root of grid cell area normalized by</span>
<span class="sd">              total area. Requires a latitude-longitude grid to be</span>
<span class="sd">              present in the input :py:mod:`cdms2` variable *dataset*.</span>
<span class="sd">              This is a fairly standard weighting strategy. If you are</span>
<span class="sd">              unsure which method to use and you have gridded data then</span>
<span class="sd">              this should be your first choice.</span>

<span class="sd">            * *&quot;coslat&quot;* : Square-root of cosine of latitude</span>
<span class="sd">              (*&quot;cos_lat&quot;* is also accepted). Requires a latitude</span>
<span class="sd">              dimension to be present in the input :py:mod:`cdms2`</span>
<span class="sd">              variable *dataset*.</span>

<span class="sd">            * *&quot;none&quot;* : Equal weights for all grid points (default).</span>

<span class="sd">            * *None* : Same as *&quot;none&quot;*.</span>

<span class="sd">             An array of weights may also be supplied instead of</span>
<span class="sd">             specifying a weighting method.</span>

<span class="sd">        *center*</span>
<span class="sd">            If *True*, the mean along the first axis of the input data</span>
<span class="sd">            set (the time-mean) will be removed prior to analysis. If</span>
<span class="sd">            *False*, the mean along the first axis will not be removed.</span>
<span class="sd">            Defaults to *True* (mean is removed). Generally this option</span>
<span class="sd">            should be set to *True* as the covariance interpretation</span>
<span class="sd">            relies on input data being anomalies with a time-mean of 0.</span>
<span class="sd">            A valid reson for turning this off would be if you have</span>
<span class="sd">            already generated an anomaly data set. Setting to *True* has</span>
<span class="sd">            the useful side-effect of propagating missing values along</span>
<span class="sd">            the time-dimension, ensuring the solver will work even if</span>
<span class="sd">            missing values occur at different locations at different</span>
<span class="sd">            times.</span>

<span class="sd">        *ddof*</span>
<span class="sd">            &#39;Delta degrees of freedom&#39;. The divisor used to normalize</span>
<span class="sd">            the covariance matrix is *N - ddof* where *N* is the</span>
<span class="sd">            number of samples. Defaults to *1*.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        EOF analysis with area-weighting for the input field:</span>

<span class="sd">        &gt;&gt;&gt; from eof2 import Eof</span>
<span class="sd">        &gt;&gt;&gt; eofobj = Eof(field, weights=&quot;area&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check that dataset is recognised by cdms2 as a variable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">EofError</span><span class="p">(</span><span class="s">&quot;the input data must be a cdms2 variable&quot;</span><span class="p">)</span>
        <span class="c"># Store the time axis as an instance variable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeax</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">getTime</span><span class="p">()</span>
        <span class="c"># Verify that a time axis was found, getTime returns None when a</span>
        <span class="c"># time axis is not found.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EofError</span><span class="p">(</span><span class="s">&quot;time axis not found&quot;</span><span class="p">)</span>
        <span class="c"># Check the dimension order of the input, time must be the first</span>
        <span class="c"># dimension.</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">getOrder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;t&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EofError</span><span class="p">(</span><span class="s">&quot;time must be the first dimension&quot;</span><span class="p">)</span>
        <span class="c"># Verify the presence of at least one spatial dimension. The</span>
        <span class="c"># instance variable channels will also be used as a partial axis</span>
        <span class="c"># list when constructing meta-data. It contains the spatial</span>
        <span class="c"># dimensions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeax</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EofError</span><span class="p">(</span><span class="s">&quot;one or more spatial dimensions are required&quot;</span><span class="p">)</span>
        <span class="c"># Store the missing value attribute of the data set in an</span>
        <span class="c"># instance variable so that it is recoverable later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
        <span class="c"># Generate an appropriate set of weights for the input dataset. There</span>
        <span class="c"># are several weighting schemes. The &quot;area&quot; weighting scheme requires</span>
        <span class="c"># a latitude-longitude grid to be present, the &quot;cos_lat&quot; scheme only</span>
        <span class="c"># requires a latitude dimension.</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="c"># No weights requested, set the weight array to None.</span>
            <span class="n">wtarray</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># Generate a weights array of the appropriate kind, with a</span>
                <span class="c"># shape compatible with the data set.</span>
                <span class="n">scheme</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">wtarray</span> <span class="o">=</span> <span class="n">weights_array</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c"># Weights is not a string, assume it is an array.</span>
                <span class="n">wtarray</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="k">except</span> <span class="n">EofToolError</span><span class="p">,</span> <span class="n">err</span><span class="p">:</span>
                <span class="c"># Weights is not recognized, raise an error.</span>
                <span class="k">raise</span> <span class="n">EofError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="c"># Cast the wtarray to the same type as the dataset. This prevents the</span>
        <span class="c"># promotion of 32-bit input to 64-bit on multiplication with the</span>
        <span class="c"># weight array when not required. This will fail with a AttributeError</span>
        <span class="c"># exception if the weights array is None, which it may be if no</span>
        <span class="c"># weighting was requested.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wtarray</span> <span class="o">=</span> <span class="n">wtarray</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c"># Create an EofSolver object using appropriate arguments for this</span>
        <span class="c"># data set. The object will be used for the decomposition and</span>
        <span class="c"># for returning the results.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span> <span class="o">=</span> <span class="n">EofSolver</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">asma</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="n">wtarray</span><span class="p">,</span>
                <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        
<div class="viewcode-block" id="Eof.pcs"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.pcs">[docs]</a>    <span class="k">def</span> <span class="nf">pcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcscaling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">npcs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Principal component time series (PCs).</span>

<span class="sd">        Returns the ordered PCs in a a :py:mod:`cdms2` variable.</span>
<span class="sd">        </span>
<span class="sd">        **Optional arguments:**</span>

<span class="sd">        *pcscaling*</span>
<span class="sd">            Set the scaling of the retrieved PCs. The following</span>
<span class="sd">            values are accepted:</span>

<span class="sd">            * *0* : Un-scaled principal components (default).</span>
<span class="sd">            * *1* : Principal components are scaled to unit variance</span>
<span class="sd">              (divided by the square-root of their eigenvalue).</span>
<span class="sd">            * *2* : Principal components are multiplied by the</span>
<span class="sd">              square-root of their eigenvalue.</span>

<span class="sd">        *npcs* : Number of principal components to retrieve. Defaults to</span>
<span class="sd">          all the principal components.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        All un-scaled PCs:</span>

<span class="sd">        &gt;&gt;&gt; pcs = eofobj.pcs()</span>

<span class="sd">        First 3 PCs scaled to unit variance:</span>

<span class="sd">        &gt;&gt;&gt; pcs = eofobj.pcs(npcs=3, pcscaling=1) </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">pcs</span><span class="p">(</span><span class="n">pcscaling</span><span class="p">,</span> <span class="n">npcs</span><span class="p">)</span>
        <span class="n">pcsax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pcs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;pc&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeax</span><span class="p">,</span> <span class="n">pcsax</span><span class="p">]</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">pcs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;pcs&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">)</span>
        <span class="n">pcs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;principal_components&quot;</span>
        <span class="n">pcs</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;principal component time series&quot;</span>
        <span class="k">return</span> <span class="n">pcs</span>
    </div>
<div class="viewcode-block" id="Eof.eofs"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.eofs">[docs]</a>    <span class="k">def</span> <span class="nf">eofs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eofscaling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">neofs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Emipirical orthogonal functions.</span>

<span class="sd">        Returns a the ordered EOFs in a :py:mod:`cdms2` variable.</span>
<span class="sd">        </span>
<span class="sd">        **Optional arguments:**</span>

<span class="sd">        *eofscaling*</span>
<span class="sd">            Sets the scaling of the EOFs. The following values are</span>
<span class="sd">            accepted:</span>

<span class="sd">            * *0* : Un-scaled EOFs (default).</span>
<span class="sd">            * *1* : EOFs are divided by the square-root of their</span>
<span class="sd">              eigenvalues.</span>
<span class="sd">            * *2* : EOFs are multiplied by the square-root of their</span>
<span class="sd">              eigenvalues.</span>
<span class="sd">              </span>
<span class="sd">        *neofs* -- Number of EOFs to return. Defaults to all EOFs.</span>
<span class="sd">        </span>
<span class="sd">        **Examples:**</span>

<span class="sd">        All EOFs with no scaling:</span>

<span class="sd">        &gt;&gt;&gt; eofs = eofobj.eofs()</span>

<span class="sd">        First 3 EOFs with scaling applied:</span>

<span class="sd">        &gt;&gt;&gt; eofs = eofobj.eofs(neofs=3, eofscaling=1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">eofs</span><span class="p">(</span><span class="n">eofscaling</span><span class="p">,</span> <span class="n">neofs</span><span class="p">)</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span>
        <span class="n">eofax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eofs</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eof&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">eofax</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">eofs</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">eofs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eofs&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span><span class="p">)</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;empirical_orthogonal_functions&quot;</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;empirical orthogonal functions&quot;</span>
        <span class="k">return</span> <span class="n">eofs</span>
    </div>
<div class="viewcode-block" id="Eof.eigenvalues"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neigs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eigenvalues (decreasing variances) associated with each EOF.</span>

<span class="sd">        Returns the ordered eigenvalues in a :py:mod:`cdms2` variable.</span>

<span class="sd">        **Optional argument:**</span>
<span class="sd">        </span>
<span class="sd">        *neigs*</span>
<span class="sd">            Number of eigenvalues to return. Defaults to all</span>
<span class="sd">            eigenvalues.</span>
<span class="sd">        </span>
<span class="sd">        **Examples:**</span>

<span class="sd">        All eigenvalues:</span>

<span class="sd">        &gt;&gt;&gt; lambdas = eofobj.eigenvalues()</span>

<span class="sd">        The first eigenvalue:</span>

<span class="sd">        &gt;&gt;&gt; lambda1 = eofobj.eigenvalues(neigs=1)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="n">neigs</span><span class="p">)</span>
        <span class="n">eofax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lambdas</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eigenvalue&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">eofax</span><span class="p">]</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">lambdas</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eigenvalues&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">)</span>
        <span class="n">lambdas</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;eigenvalues&quot;</span>
        <span class="n">lambdas</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;eigenvalues&quot;</span>
        <span class="k">return</span> <span class="n">lambdas</span>
        </div>
<div class="viewcode-block" id="Eof.eofsAsCorrelation"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.eofsAsCorrelation">[docs]</a>    <span class="k">def</span> <span class="nf">eofsAsCorrelation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neofs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EOFs scaled as the correlation of the PCs with the original</span>
<span class="sd">        field.</span>
<span class="sd">        </span>
<span class="sd">        Returns the ordered correlation EOFs in a :py:mod:`cdms2`</span>
<span class="sd">        variable.</span>
<span class="sd">        </span>
<span class="sd">        **Optional argument:**</span>
<span class="sd">        </span>
<span class="sd">        *neofs*</span>
<span class="sd">            Number of EOFs to return. Defaults to all EOFs.</span>
<span class="sd">        </span>
<span class="sd">        **Note:**</span>
<span class="sd">        </span>
<span class="sd">        These are only the EOFs expressed as correlation and are not</span>
<span class="sd">        related to EOFs computed using the correlation matrix.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        All EOFs:</span>

<span class="sd">        &gt;&gt;&gt; eofs = eofobj.eofsAsCorrelation()</span>

<span class="sd">        The leading EOF:</span>

<span class="sd">        &gt;&gt;&gt; eof1 = eofobj.eofsAsCorrelation(neofs=1)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCorrelation</span><span class="p">(</span><span class="n">neofs</span><span class="p">)</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span>
        <span class="n">eofax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eofs</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eof&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">eofax</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">eofs</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">eofs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eofs_corr&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span><span class="p">)</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;empirical_orthogonal_functions&quot;</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;correlation between principal components and data&quot;</span>
        <span class="k">return</span> <span class="n">eofs</span>
    </div>
<div class="viewcode-block" id="Eof.eofsAsCovariance"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.eofsAsCovariance">[docs]</a>    <span class="k">def</span> <span class="nf">eofsAsCovariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neofs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pcscaling</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EOFs scaled as the covariance of the PCs with the original</span>
<span class="sd">        field.</span>

<span class="sd">        Returns the ordered covariance EOFs in a :py:mod:`cdms2`</span>
<span class="sd">        variable.</span>
<span class="sd">        </span>
<span class="sd">        **Optional arguments:**</span>
<span class="sd">        </span>
<span class="sd">        *neofs*</span>
<span class="sd">            Number of EOFs to return. Defaults to all EOFs.</span>
<span class="sd">        </span>
<span class="sd">        *pcscaling*</span>
<span class="sd">            Set the scaling of the PCs used to compute covariance. The</span>
<span class="sd">            following values are accepted:</span>

<span class="sd">            * *0* : Un-scaled PCs.</span>
<span class="sd">            * *1* : PCs are scaled to unit variance (divided by the</span>
<span class="sd">              square-root of their eigenvalue) (default).</span>
<span class="sd">            * *2* : PCs are multiplied by the square-root of their</span>
<span class="sd">              eigenvalue.</span>

<span class="sd">        **Examples:**</span>
<span class="sd">        </span>
<span class="sd">        All EOFs:</span>

<span class="sd">        &gt;&gt;&gt; eofs = eofobj.eofsAsCovariance()</span>

<span class="sd">        The leading EOF:</span>

<span class="sd">        &gt;&gt;&gt; eof1 = eofobj.eofsAsCovariance(neofs=1)</span>

<span class="sd">        The leading EOF using un-scaled PCs:</span>

<span class="sd">        &gt;&gt;&gt; eof1 = eofobj.eofsAsCovariance(neofs=1, pcscaling=0)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">(</span><span class="n">neofs</span><span class="p">,</span> <span class="n">pcscaling</span><span class="p">)</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span>
        <span class="n">eofax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eofs</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eof&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">eofax</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">eofs</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">eofs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eofs_cov&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span><span class="p">)</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;empirical_orthogonal_functions&quot;</span>
        <span class="n">eofs</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;covariance between principal components and data&quot;</span>
        <span class="k">return</span> <span class="n">eofs</span>
    </div>
<div class="viewcode-block" id="Eof.varianceFraction"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.varianceFraction">[docs]</a>    <span class="k">def</span> <span class="nf">varianceFraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neigs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional EOF variances.</span>
<span class="sd">        </span>
<span class="sd">        The fraction of the total variance explained by each EOF, a</span>
<span class="sd">        value between 0 and 1 inclusive, in a :py:mod:`cdms2` variable.</span>

<span class="sd">        **Optional argument:**</span>

<span class="sd">        *neigs*</span>
<span class="sd">            Number of eigenvalues to return the fractional variance for.</span>
<span class="sd">            Defaults to all eigenvalues.</span>
<span class="sd">        </span>
<span class="sd">        **Examples:**</span>

<span class="sd">        The fractional variance represented by each eigenvalue:</span>

<span class="sd">        &gt;&gt;&gt; varfrac = eofobj.varianceFraction()</span>

<span class="sd">        The fractional variance represented by the first 3 eigenvalues:</span>

<span class="sd">        &gt;&gt;&gt; varfrac = eofobj.VarianceFraction(neigs=3)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vfrac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">varianceFraction</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="n">neigs</span><span class="p">)</span>
        <span class="n">eofax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vfrac</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eigenvalue&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">eofax</span><span class="p">]</span>
        <span class="n">vfrac</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">vfrac</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;variance&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">)</span>
        <span class="n">vfrac</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;variance_fraction&quot;</span>
        <span class="n">vfrac</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;variance fraction&quot;</span>
        <span class="k">return</span> <span class="n">vfrac</span>
        </div>
<div class="viewcode-block" id="Eof.totalAnomalyVariance"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.totalAnomalyVariance">[docs]</a>    <span class="k">def</span> <span class="nf">totalAnomalyVariance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total variance associated with the field of anomalies (the sum</span>
<span class="sd">        of the eigenvalues).</span>
<span class="sd">        </span>
<span class="sd">        Returns a scalar (not a :py:mod:`cdms2` transient variable).</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; var = eofobj.totalAnomalyVariance()</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">totalAnomalyVariance</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="Eof.reconstructedField"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.reconstructedField">[docs]</a>    <span class="k">def</span> <span class="nf">reconstructedField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neofs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reconstructed data field based on a subset of EOFs.</span>

<span class="sd">        If weights were passed to the :py:class:`~eof2.Eof` instance</span>
<span class="sd">        then the returned reconstructed field will be automatically</span>
<span class="sd">        un-weighted. Otherwise the returned reconstructed field will</span>
<span class="sd">        be weighted in the same manner as the input to the</span>
<span class="sd">        :py:class:`~eof2.Eof` instance.</span>
<span class="sd">        </span>
<span class="sd">        **Argument:**</span>
<span class="sd">        </span>
<span class="sd">        *neofs*</span>
<span class="sd">            Number of EOFs to use for the reconstruction.</span>
<span class="sd">        </span>
<span class="sd">        **Examples:**</span>

<span class="sd">        Reconstruct the input field using 3 EOFs.</span>

<span class="sd">        &gt;&gt;&gt; rfield = eofobj.reconstructedField(neofs=3)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rfield</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">reconstructedField</span><span class="p">(</span><span class="n">neofs</span><span class="p">)</span>
        <span class="n">rfield</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeax</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">rfield</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">rfield</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;rcon&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missingValue</span><span class="p">)</span>
        <span class="n">rfield</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;reconstructed_field&quot;</span>
        <span class="k">return</span> <span class="n">rfield</span>
    </div>
<div class="viewcode-block" id="Eof.northTest"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.northTest">[docs]</a>    <span class="k">def</span> <span class="nf">northTest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neigs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vfscaled</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Typical errors for eigenvalues.</span>
<span class="sd">        </span>
<span class="sd">        Returns the typical error for each eigenvalue in a</span>
<span class="sd">        :py:mod:`cdms2` variable.</span>

<span class="sd">        The method of North et al. (1982) is used to compute the typical</span>
<span class="sd">        error for each eigenvalue. It is assumed that the number of</span>
<span class="sd">        times in the input data set is the same as the number of</span>
<span class="sd">        independent realizations. If this assumption is not valid then</span>
<span class="sd">        the result may be inappropriate.</span>
<span class="sd">        </span>
<span class="sd">        **Optional arguments:**</span>
<span class="sd">        </span>
<span class="sd">        *neigs*</span>
<span class="sd">            The number of eigenvalues to return typical errors for.</span>
<span class="sd">            Defaults to typical errors for all eigenvalues.</span>
<span class="sd">            </span>
<span class="sd">        *vfscaled*</span>
<span class="sd">            If *True* scale the errors by the sum of the eigenvalues.</span>
<span class="sd">            This yields typical errors with the same scale as the</span>
<span class="sd">            values returned by the</span>
<span class="sd">            :py:meth:`~eof2.Eof.varianceFraction` method. If *False*</span>
<span class="sd">            then no scaling is done. Defaults to *False* (no scaling).</span>
<span class="sd">        </span>
<span class="sd">        **References**</span>

<span class="sd">        North, G. R., T. L. Bell, R. F. Cahalan, and F. J. Moeng, 1982:</span>
<span class="sd">        &quot;Sampling errors in the estimation of empirical orthogonal</span>
<span class="sd">        functions&quot;, *Monthly Weather Review*, **110**, pages 669-706.</span>
<span class="sd">        </span>
<span class="sd">        **Examples:**</span>
<span class="sd">        </span>
<span class="sd">        Typical errors for all eigenvalues:</span>

<span class="sd">        &gt;&gt;&gt; errs = eofobj.northTest()</span>

<span class="sd">        Typical errors for the first 3 eigenvalues scaled by the sum of</span>
<span class="sd">        the eigenvalues:</span>

<span class="sd">        &gt;&gt;&gt; errs = eofobj.northTest(neigs=3, vfscaled=True)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typerrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">northTest</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="n">neigs</span><span class="p">,</span> <span class="n">vfscaled</span><span class="o">=</span><span class="n">vfscaled</span><span class="p">)</span>
        <span class="n">eofax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">typerrs</span><span class="p">)),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;eigenvalue&quot;</span><span class="p">)</span>
        <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">eofax</span><span class="p">]</span>
        <span class="n">typerrs</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">typerrs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;typical_errors&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">)</span>
        <span class="n">typerrs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;typical_errors&quot;</span>
        <span class="n">typerrs</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;north_typical_errors&quot;</span>
        <span class="k">return</span> <span class="n">typerrs</span>
</div>
<div class="viewcode-block" id="Eof.getWeights"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.getWeights">[docs]</a>    <span class="k">def</span> <span class="nf">getWeights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weights used for the analysis.</span>
<span class="sd">        </span>
<span class="sd">        **Examples:**</span>

<span class="sd">        The 2D weights variable used for the analysis:</span>

<span class="sd">        &gt;&gt;&gt; wgt = eofobj.getWeights()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">getWeights</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;weights&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">)</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;weights&quot;</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;grid_weights&quot;</span>
        <span class="k">return</span> <span class="n">weights</span>
</div>
<div class="viewcode-block" id="Eof.projectField"><a class="viewcode-back" href="../../references.html#eof2.eofwrap.Eof.projectField">[docs]</a>    <span class="k">def</span> <span class="nf">projectField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">neofs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eofscaling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project a field onto the EOFs.</span>
<span class="sd">        </span>
<span class="sd">        Returns projected time series in a :py:mod:`cdms2` variable.</span>

<span class="sd">        Given a field, projects it onto the EOFs to generate a</span>
<span class="sd">        corresponding set of time series in a :py:mod:`cdms2` variable.</span>
<span class="sd">        The field can be projected onto all the EOFs or just a subset.</span>
<span class="sd">        The field must have the same corresponding spatial dimensions</span>
<span class="sd">        (including missing values in the same places) as the original</span>
<span class="sd">        input to the :py:class:`~eof2.Eof` instance. The field may have</span>
<span class="sd">        a different length time dimension to the original input field</span>
<span class="sd">        (or no time dimension at all). The time dimension must be first</span>
<span class="sd">        if present.</span>
<span class="sd">        </span>
<span class="sd">        **Argument:**</span>
<span class="sd">        </span>
<span class="sd">        *field*</span>
<span class="sd">            A field (:py:mod:`cdms2` variable) to project onto the EOFs.</span>

<span class="sd">        **Optional arguments:**</span>

<span class="sd">        *neofs*</span>
<span class="sd">            Number of EOFs to project onto. Defaults to all EOFs.</span>

<span class="sd">        *eofscaling*</span>
<span class="sd">            Set the scaling of the EOFs that are projected</span>
<span class="sd">            onto. The following values are accepted:</span>

<span class="sd">            * *0* : Un-scaled EOFs (default).</span>
<span class="sd">            * *1* : EOFs are divided by the square-root of their eigenvalue.</span>
<span class="sd">            * *2* : EOFs are multiplied by the square-root of their</span>
<span class="sd">              eigenvalue.</span>

<span class="sd">        *weighted*</span>
<span class="sd">            If *True* then the field is weighted prior to projection. If</span>
<span class="sd">            *False* then no weighting is applied. Defaults to *True*</span>
<span class="sd">            (weighting is applied). Generally only the default setting</span>
<span class="sd">            should be used.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        Project a field onto all EOFs:</span>

<span class="sd">        &gt;&gt;&gt; pcs = eofobj.projectField(field)</span>

<span class="sd">        Project fields onto the three leading EOFs:</span>

<span class="sd">        &gt;&gt;&gt; pcs = eofobj.projectField(field, neofs=3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Compute the projected PCs.</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eofobj</span><span class="o">.</span><span class="n">projectField</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">asma</span><span class="p">(),</span> <span class="n">neofs</span><span class="o">=</span><span class="n">neofs</span><span class="p">,</span>
                <span class="n">eofscaling</span><span class="o">=</span><span class="n">eofscaling</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">)</span>
        <span class="c"># Construct the required axes.</span>
        <span class="k">if</span> <span class="n">pcs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># 2D PCs require a time axis and a PC axis.</span>
            <span class="n">pcsax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pcs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;pc&quot;</span><span class="p">)</span>
            <span class="n">timeax</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># time is assumed to be first anyway</span>
            <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">timeax</span><span class="p">,</span> <span class="n">pcsax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># 1D PCs require only a PC axis.</span>
            <span class="n">pcsax</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pcs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;pc&quot;</span><span class="p">)</span>
            <span class="n">axlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">pcsax</span><span class="p">]</span>
        <span class="c"># Apply meta data to the projected PCs.</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">pcs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;pcs&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axlist</span><span class="p">)</span>
        <span class="n">pcs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;principal_components&quot;</span>
        <span class="n">pcs</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s">&quot;principal component time series&quot;</span>
        <span class="k">return</span> <span class="n">pcs</span>

</div></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3>Table Of Contents</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../eofs.html">EOF Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">API References</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../index.html">eof2 1.5.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Andrew Dawson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>