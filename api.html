
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Full API Reference &mdash; eof2 1.5.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/extension.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="eof2 1.5.0 documentation" href="index.html" />
    <link rel="prev" title="Non-metadata Interface Reference" href="refsolve.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="refsolve.html" title="Non-metadata Interface Reference"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">eof2 1.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="full-api-reference">
<h1>Full API Reference<a class="headerlink" href="#full-api-reference" title="Permalink to this headline">¶</a></h1>
<p>The following is the documentation for the full <a class="reference internal" href="#module-eof2" title="eof2"><tt class="xref py py-mod docutils literal"><span class="pre">eof2</span></tt></a> API.</p>
<span class="target" id="module-eof2"></span><p>Fast and efficient EOF analysis for Python.</p>
<dl class="exception">
<dt id="eof2.EofError">
<em class="property">exception </em><tt class="descclassname">eof2.</tt><tt class="descname">EofError</tt><a class="headerlink" href="#eof2.EofError" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic exception class for errors in the eof2 package.</p>
</dd></dl>

<dl class="exception">
<dt id="eof2.EofToolError">
<em class="property">exception </em><tt class="descclassname">eof2.</tt><tt class="descname">EofToolError</tt><a class="headerlink" href="#eof2.EofToolError" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic exception class for errors in the supplementary tools.</p>
</dd></dl>

<dl class="class">
<dt id="eof2.EofSolver">
<em class="property">class </em><tt class="descclassname">eof2.</tt><tt class="descname">EofSolver</tt><big>(</big><em>dataset</em>, <em>weights=None</em>, <em>center=True</em>, <em>ddof=1</em><big>)</big><a class="headerlink" href="#eof2.EofSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>EOF analysis (<tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> interface).</p>
<p>Create an EofSolver object.</p>
<p>The EOF solution is computed at initialization time. Method
calls are used to retrieve computed quantities.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt><em>dataset</em></dt>
<dd>A <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ma.core.MasekdArray</span></tt> with two or more
dimensions containing the data to be analysed. The first
dimension is assumed to represent time. Missing values are
permitted, either in the form of a masked array, or the
value <tt class="xref py py-attr docutils literal"><span class="pre">numpy.nan</span></tt>. Missing values must be constant
with time (e.g., values of an oceanographic field over
land).</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>weights</em></dt>
<dd>An array of weights whose shape is compatible with those of
the input array <em>dataset</em>. The weights can have the same
shape as the input data set or a shape compatible with an
array broadcast operation (ie. the shape of the weights can
can match the rightmost parts of the shape of the input
array <em>dataset</em>). If the input array <em>dataset</em> does not
require weighting then the value <em>None</em> may be used.
Defaults to <em>None</em> (no weighting).</dd>
<dt><em>center</em></dt>
<dd>If <em>True</em>, the mean along the first axis of the input data
set (the time-mean) will be removed prior to analysis. If
<em>False</em>, the mean along the first axis will not be removed.
Defaults to <em>True</em> (mean is removed). Generally this option
should be set to <em>True</em> as the covariance interpretation
relies on input data being anomalies with a time-mean of 0.
A valid reson for turning this off would be if you have
already generated an anomaly data set. Setting to <em>True</em> has
the useful side-effect of propagating missing values along
the time-dimension, ensuring the solver will work even if
missing values occur at different locations at different
times.</dd>
<dt><em>ddof</em></dt>
<dd>&#8216;Delta degrees of freedom&#8217;. The divisor used to normalize
the covariance matrix is <em>N - ddof</em> where <em>N</em> is the
number of samples. Defaults to <em>1</em>.</dd>
</dl>
<dl class="method">
<dt id="eof2.EofSolver.eigenvalues">
<tt class="descname">eigenvalues</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues (decreasing variances) associated with each EOF.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return. Defaults to all
eigenvalues.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.eofs">
<tt class="descname">eofs</tt><big>(</big><em>eofscaling=0</em>, <em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.eofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Empirical orthogonal functions (EOFs).</p>
<p>Returns an array with the ordered EOFs along the first
dimension.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>eofscaling</em></dt>
<dd><p class="first">Sets the scaling of the EOFs. The following values are
accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their
eigenvalues.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalues.</li>
</ul>
</dd>
</dl>
<p><em>neofs</em> &#8211; Number of EOFs to return. Defaults to all EOFs.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.eofsAsCorrelation">
<tt class="descname">eofsAsCorrelation</tt><big>(</big><em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.eofsAsCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the correlation of the PCs with the original
field.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.eofsAsCovariance">
<tt class="descname">eofsAsCovariance</tt><big>(</big><em>neofs=None</em>, <em>pcscaling=1</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.eofsAsCovariance" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the covariance of the PCs with the original
field.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the PCs used to compute covariance. The
following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled PCs.</li>
<li><em>1</em> : PCs are scaled to unit variance (divided by the
square-root of their eigenvalue) (default).</li>
<li><em>2</em> : PCs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.getWeights">
<tt class="descname">getWeights</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.EofSolver.getWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Weights used for the analysis.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.northTest">
<tt class="descname">northTest</tt><big>(</big><em>neigs=None</em>, <em>vfscaled=False</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.northTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Typical errors for eigenvalues.</p>
<p>The method of North et al. (1982) is used to compute the typical
error for each eigenvalue. It is assumed that the number of
times in the input data set is the same as the number of
independent realizations. If this assumption is not valid then
the result may be inappropriate.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>The number of eigenvalues to return typical errors for.
Defaults to typical errors for all eigenvalues.</dd>
<dt><em>vfscaled</em></dt>
<dd>If <em>True</em> scale the errors by the sum of the eigenvalues.
This yields typical errors with the same scale as the
values returned by the
<a class="reference internal" href="#eof2.EofSolver.varianceFraction" title="eof2.EofSolver.varianceFraction"><tt class="xref py py-meth docutils literal"><span class="pre">varianceFraction()</span></tt></a> method. If
<em>False</em> then no scaling is done. Defaults to <em>False</em> (no
scaling).</dd>
</dl>
<p><strong>References</strong></p>
<p>North, G. R., T. L. Bell, R. F. Cahalan, and F. J. Moeng, 1982:
&#8220;Sampling errors in the estimation of empirical orthogonal
functions&#8221;, <em>Monthly Weather Review</em>, <strong>110</strong>, pages 669-706.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.pcs">
<tt class="descname">pcs</tt><big>(</big><em>pcscaling=0</em>, <em>npcs=None</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.pcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal component time series (PCs).</p>
<p>Returns an array where the columns are the ordered PCs.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the retrieved PCs. The following
values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled PCs (default).</li>
<li><em>1</em> : PCs are scaled to unit variance (divided by the
square-root of their eigenvalue).</li>
<li><em>2</em> : PCs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
</dl>
<p><em>npcs</em> : Number of PCs to retrieve. Defaults to all the PCs.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.projectField">
<tt class="descname">projectField</tt><big>(</big><em>field</em>, <em>neofs=None</em>, <em>eofscaling=0</em>, <em>weighted=True</em>, <em>notime=False</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.projectField" title="Permalink to this definition">¶</a></dt>
<dd><p>Project a field onto the EOFs.</p>
<p>Given a field, projects it onto the EOFs to generate a
corresponding set of time series. The field can be projected
onto all the EOFs or just a subset. The field must have the same
corresponding spatial dimensions (including missing values in
the same places) as the original input to the
<a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a> instance. The field may have a
different length time dimension to the original input field (or
no time dimension at all).</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>field</em></dt>
<dd>A field to project onto the EOFs. The field should be
contained in a <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt> or a
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ma.core.MaskedArray</span></tt>.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to project onto. Defaults to all EOFs.</dd>
<dt><em>eofscaling</em></dt>
<dd><p class="first">Set the scaling of the EOFs that are projected
onto. The following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their eigenvalue.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
<dt><em>weighted</em></dt>
<dd>If <em>True</em> then the EOFs are weighted prior to projection. If
<em>False</em> then no weighting is applied. Defaults to <em>True</em>
(weighting is applied). Generally only the default setting
should be used.</dd>
<dt><em>notime</em></dt>
<dd>If <em>True</em>, indicates that the input field has no time
dimension and should be treated as spatial data. If <em>False</em>
then the first dimension of the field will be assumed to be
a time dimension. Defaults to <em>False</em> (a time dimension is
assumed).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.reconstructedField">
<tt class="descname">reconstructedField</tt><big>(</big><em>neofs</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.reconstructedField" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructed data field based on a subset of EOFs.</p>
<p>If weights were passed to the <a class="reference internal" href="#eof2.EofSolver" title="eof2.EofSolver"><tt class="xref py py-class docutils literal"><span class="pre">EofSolver</span></tt></a>
instance then the returned reconstructed field will be
automatically un-weighted. Otherwise the returned reconstructed
field will  be weighted in the same manner as the input to the
<a class="reference internal" href="#eof2.EofSolver" title="eof2.EofSolver"><tt class="xref py py-class docutils literal"><span class="pre">EofSolver</span></tt></a> instance.</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to use for the reconstruction.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.totalAnomalyVariance">
<tt class="descname">totalAnomalyVariance</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.EofSolver.totalAnomalyVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Total variance associated with the field of anomalies (the sum
of the eigenvalues).</p>
</dd></dl>

<dl class="method">
<dt id="eof2.EofSolver.varianceFraction">
<tt class="descname">varianceFraction</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.EofSolver.varianceFraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional EOF variances.</p>
<p>The fraction of the total variance explained by each EOF. This
is a value between 0 and 1 inclusive.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return the fractional variance for.
Defaults to all eigenvalues.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="eof2.EofNumPy">
<tt class="descclassname">eof2.</tt><tt class="descname">EofNumPy</tt><a class="headerlink" href="#eof2.EofNumPy" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#eof2.EofSolver" title="eof2.EofSolver"><tt class="xref py py-class docutils literal"><span class="pre">EofSolver</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="eof2.MultipleEofSolver">
<em class="property">class </em><tt class="descclassname">eof2.</tt><tt class="descname">MultipleEofSolver</tt><big>(</big><em>*datasets</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiple EOF analysis (<tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> interface).</p>
<p>Create a MultipleEofSolver object.</p>
<p>The EOF solution is computed at initialization time. Method
calls are used to retrieve computed quantities.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt><em>*datasets</em></dt>
<dd>One or more <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray`s</span> <span class="pre">or</span>
<span class="pre">:py:class:`numpy.ma.core.MasekdArray`s</span> <span class="pre">with</span> <span class="pre">two</span> <span class="pre">or</span> <span class="pre">more</span>
<span class="pre">dimensions</span> <span class="pre">containing</span> <span class="pre">the</span> <span class="pre">data</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">analysed.</span> <span class="pre">The</span> <span class="pre">first</span>
<span class="pre">dimension</span> <span class="pre">of</span> <span class="pre">each</span> <span class="pre">array</span> <span class="pre">is</span> <span class="pre">assumed</span> <span class="pre">to</span> <span class="pre">represent</span> <span class="pre">time.</span>
<span class="pre">Missing</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">permitted,</span> <span class="pre">either</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">form</span> <span class="pre">of</span> <span class="pre">masked</span>
<span class="pre">arrays,</span> <span class="pre">or</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">:py:attr:`numpy.nan</span></tt>. Missing values
must be constant with time (e.g., values of an oceanographic
field over land).</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>weights</em></dt>
<dd>A sequence of arrays of weights whose shapes are compatible
with those of the input data sets. The weights can have the
same shape as the input data set or a shape compatible with
a an array broadcast operation (ie. the shape of the weights
can match the rightmost parts of the shape of the input data
set). If none of the input data sets require weighting then
the single value <em>None</em> may be used. Defaults to <em>None</em> (no
weighting for any data set).</dd>
<dt><em>center</em></dt>
<dd>If <em>True</em>, the mean along the first axis of the input data
set (the time-mean) will be removed prior to analysis. If
<em>False</em>, the mean along the first axis will not be removed.
Defaults to <em>True</em> (mean is removed). Generally this option
should be set to <em>True</em> as the covariance interpretation
relies on input data being anomalies with a time-mean of 0.
A valid reson for turning this off would be if you have
already generated an anomaly data set. Setting to <em>True</em> has
the useful side-effect of propagating missing values along
the time-dimension, ensuring the solver will work even if
missing values occur at different locations at different
times.</dd>
<dt><em>ddof</em></dt>
<dd>&#8216;Delta degrees of freedom&#8217;. The divisor used to normalize
the covariance matrix is <em>N - ddof</em> where <em>N</em> is the
number of samples. Defaults to <em>1</em>.</dd>
</dl>
<dl class="method">
<dt id="eof2.MultipleEofSolver.eigenvalues">
<tt class="descname">eigenvalues</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues (decreasing variances) associated with each EOF.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return. Defaults to all
eigenvalues.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.eofs">
<tt class="descname">eofs</tt><big>(</big><em>eofscaling=0</em>, <em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.eofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Empirical orthogonal functions (EOFs).</p>
<p>Returns arrays with the ordered EOFs along the first
dimension.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>eofscaling</em></dt>
<dd><p class="first">Sets the scaling of the EOFs. The following values are
accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their
eigenvalues.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalues.</li>
</ul>
</dd>
</dl>
<p><em>neofs</em> &#8211; Number of EOFs to return. Defaults to all EOFs.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.eofsAsCorrelation">
<tt class="descname">eofsAsCorrelation</tt><big>(</big><em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.eofsAsCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the correlation of the PCs with the original
field.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.eofsAsCovariance">
<tt class="descname">eofsAsCovariance</tt><big>(</big><em>neofs=None</em>, <em>pcscaling=1</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.eofsAsCovariance" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the covariance of the PCs with the original
field.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the PCs used to compute covariance. The
following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled PCs.</li>
<li><em>1</em> : PCs are scaled to unit variance (divided by the
square-root of their eigenvalue) (default).</li>
<li><em>2</em> : PCs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.getWeights">
<tt class="descname">getWeights</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.getWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Weights used for the analysis.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.northTest">
<tt class="descname">northTest</tt><big>(</big><em>neigs=None</em>, <em>vfscaled=False</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.northTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Typical errors for eigenvalues.</p>
<p>The method of North et al. (1982) is used to compute the typical
error for each eigenvalue. It is assumed that the number of
times in the input data set is the same as the number of
independent realizations. If this assumption is not valid then
the result may be inappropriate.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>The number of eigenvalues to return typical errors for.
Defaults to typical errors for all eigenvalues.</dd>
<dt><em>vfscaled</em></dt>
<dd>If <em>True</em> scale the errors by the sum of the eigenvalues.
This yields typical errors with the same scale as the
values returned by the
<a class="reference internal" href="#eof2.MultipleEofSolver.varianceFraction" title="eof2.MultipleEofSolver.varianceFraction"><tt class="xref py py-meth docutils literal"><span class="pre">varianceFraction()</span></tt></a>
method. If <em>False</em> then no scaling is done. Defaults to
<em>False</em> (no scaling).</dd>
</dl>
<p><strong>References</strong></p>
<p>North, G. R., T. L. Bell, R. F. Cahalan, and F. J. Moeng, 1982:
&#8220;Sampling errors in the estimation of empirical orthogonal
functions&#8221;, <em>Monthly Weather Review</em>, <strong>110</strong>, pages 669-706.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.pcs">
<tt class="descname">pcs</tt><big>(</big><em>pcscaling=0</em>, <em>npcs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.pcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal component time series (PCs).</p>
<p>Returns an array where the columns are the ordered PCs.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the retrieved PCs. The following
values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled PCs (default).</li>
<li><em>1</em> : PCs are scaled to unit variance (divided by the
square-root of their eigenvalue).</li>
<li><em>2</em> : PCs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
</dl>
<p><em>npcs</em> : Number of PCs to retrieve. Defaults to all the PCs.</p>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.projectField">
<tt class="descname">projectField</tt><big>(</big><em>*fields</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.projectField" title="Permalink to this definition">¶</a></dt>
<dd><p>Project a set of fields onto the EOFs.</p>
<p>Given a set of fields, projects them onto the EOFs to generate
a corresponding set of time series. Fields can be projected onto
all the EOFs or just a subset. There must be the same number of 
fields as were originally input into the
<a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a> instance, and each field
must have the same corresponding spatial dimensions (including
missing values in the same places). The fields may have a
different length time dimension to the original input fields (or
no time dimension at all).</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>*fields</em></dt>
<dd>One or more fields to project onto the EOFs. The number of
fields must be the same as the number of fields used to
initialize the <a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a>
instance.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>missing</em></dt>
<dd>The missing value for all fields, or a list of the
missing value for each field. If not supplied no particular
value is assumed to be missing. Note that if 
<tt class="xref py py-attr docutils literal"><span class="pre">numpy.nan</span></tt> is used to represent missing values
then this option does not need to be used as this case is
handled automatically by the solver.</dd>
<dt><em>neofs</em></dt>
<dd>Number of EOFs to project onto. Defaults to all EOFs.</dd>
<dt><em>eofscaling</em></dt>
<dd><p class="first">Set the scaling of the EOFs that are projected
onto. The following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their eigenvalue.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
<dt><em>weighted</em></dt>
<dd>If <em>True</em> then the EOFs are weighted prior to projection. If
<em>False</em> then no weighting is applied. Defaults to <em>True</em>
(weighting is applied). Generally only the default setting
should be used.</dd>
<dt><em>notime</em></dt>
<dd>If <em>True</em>, indicates that the input fields have no time
dimension and should be treated as spatial data. If <em>False</em>
then the first dimension of each input field will be assumed
to be a time dimension. Defaults to <em>False</em> (a time
dimension is assumed).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.reconstructedField">
<tt class="descname">reconstructedField</tt><big>(</big><em>neofs</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.reconstructedField" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructed data field based on a subset of EOFs.</p>
<p>If weights were passed to the
<a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a> instance then the returned
reconstructed field will be automatically un-weighted. Otherwise
the returned reconstructed field will  be weighted in the same
manner as the input to the
<a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a> instance.</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to use for the reconstruction.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.totalAnomalyVariance">
<tt class="descname">totalAnomalyVariance</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.totalAnomalyVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Total variance associated with the field of anomalies (the sum
of the eigenvalues).</p>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEofSolver.varianceFraction">
<tt class="descname">varianceFraction</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEofSolver.varianceFraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional EOF variances.</p>
<p>The fraction of the total variance explained by each EOF. This
is a value between 0 and 1 inclusive.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return the fractional variance for.
Defaults to all eigenvalues.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eof2.Eof">
<em class="property">class </em><tt class="descclassname">eof2.</tt><tt class="descname">Eof</tt><big>(</big><em>dataset</em>, <em>weights='none'</em>, <em>center=True</em>, <em>ddof=1</em><big>)</big><a class="headerlink" href="#eof2.Eof" title="Permalink to this definition">¶</a></dt>
<dd><p>EOF analysis (meta-data enabled <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> interface).</p>
<p>Create an Eof object.</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>dataset</em></dt>
<dd>A <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable containing the data to be
analyzed. Time must be the first dimension. Missing values
are allowed provided that they are constant with time (e.g.,
values of an oceanographic field over land).</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>weights</em></dt>
<dd><p class="first">Sets the weighting method. The following values are
accepted:</p>
<ul class="simple">
<li><em>&#8220;area&#8221;</em> : Square-root of grid cell area normalized by
total area. Requires a latitude-longitude grid to be
present in the input <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable <em>dataset</em>.
This is a fairly standard weighting strategy. If you are
unsure which method to use and you have gridded data then
this should be your first choice.</li>
<li><em>&#8220;coslat&#8221;</em> : Square-root of cosine of latitude
(<em>&#8220;cos_lat&#8221;</em> is also accepted). Requires a latitude
dimension to be present in the input <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt>
variable <em>dataset</em>.</li>
<li><em>&#8220;none&#8221;</em> : Equal weights for all grid points (default).</li>
<li><em>None</em> : Same as <em>&#8220;none&#8221;</em>.</li>
</ul>
<blockquote class="last">
<div>An array of weights may also be supplied instead of
specifying a weighting method.</div></blockquote>
</dd>
<dt><em>center</em></dt>
<dd>If <em>True</em>, the mean along the first axis of the input data
set (the time-mean) will be removed prior to analysis. If
<em>False</em>, the mean along the first axis will not be removed.
Defaults to <em>True</em> (mean is removed). Generally this option
should be set to <em>True</em> as the covariance interpretation
relies on input data being anomalies with a time-mean of 0.
A valid reson for turning this off would be if you have
already generated an anomaly data set. Setting to <em>True</em> has
the useful side-effect of propagating missing values along
the time-dimension, ensuring the solver will work even if
missing values occur at different locations at different
times.</dd>
<dt><em>ddof</em></dt>
<dd>&#8216;Delta degrees of freedom&#8217;. The divisor used to normalize
the covariance matrix is <em>N - ddof</em> where <em>N</em> is the
number of samples. Defaults to <em>1</em>.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>EOF analysis with area-weighting for the input field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">eof2</span> <span class="kn">import</span> <span class="n">Eof</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eofobj</span> <span class="o">=</span> <span class="n">Eof</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s">&quot;area&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="eof2.Eof.eigenvalues">
<tt class="descname">eigenvalues</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.Eof.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues (decreasing variances) associated with each EOF.</p>
<p>Returns the ordered eigenvalues in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return. Defaults to all
eigenvalues.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>All eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lambdas</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
</pre></div>
</div>
<p>The first eigenvalue:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lambda1</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.eofs">
<tt class="descname">eofs</tt><big>(</big><em>eofscaling=0</em>, <em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.Eof.eofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Emipirical orthogonal functions.</p>
<p>Returns a the ordered EOFs in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>eofscaling</em></dt>
<dd><p class="first">Sets the scaling of the EOFs. The following values are
accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their
eigenvalues.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalues.</li>
</ul>
</dd>
</dl>
<p><em>neofs</em> &#8211; Number of EOFs to return. Defaults to all EOFs.</p>
<p><strong>Examples:</strong></p>
<p>All EOFs with no scaling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofs</span><span class="p">()</span>
</pre></div>
</div>
<p>First 3 EOFs with scaling applied:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofs</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">eofscaling</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.eofsAsCorrelation">
<tt class="descname">eofsAsCorrelation</tt><big>(</big><em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.Eof.eofsAsCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the correlation of the PCs with the original
field.</p>
<p>Returns the ordered correlation EOFs in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt>
variable.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
</dl>
<p><strong>Note:</strong></p>
<p>These are only the EOFs expressed as correlation and are not
related to EOFs computed using the correlation matrix.</p>
<p><strong>Examples:</strong></p>
<p>All EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCorrelation</span><span class="p">()</span>
</pre></div>
</div>
<p>The leading EOF:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eof1</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCorrelation</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.eofsAsCovariance">
<tt class="descname">eofsAsCovariance</tt><big>(</big><em>neofs=None</em>, <em>pcscaling=1</em><big>)</big><a class="headerlink" href="#eof2.Eof.eofsAsCovariance" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the covariance of the PCs with the original
field.</p>
<p>Returns the ordered covariance EOFs in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt>
variable.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the PCs used to compute covariance. The
following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled PCs.</li>
<li><em>1</em> : PCs are scaled to unit variance (divided by the
square-root of their eigenvalue) (default).</li>
<li><em>2</em> : PCs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>All EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">()</span>
</pre></div>
</div>
<p>The leading EOF:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eof1</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The leading EOF using un-scaled PCs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eof1</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pcscaling</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.getWeights">
<tt class="descname">getWeights</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.Eof.getWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Weights used for the analysis.</p>
<p><strong>Examples:</strong></p>
<p>The 2D weights variable used for the analysis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">wgt</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">getWeights</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.northTest">
<tt class="descname">northTest</tt><big>(</big><em>neigs=None</em>, <em>vfscaled=False</em><big>)</big><a class="headerlink" href="#eof2.Eof.northTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Typical errors for eigenvalues.</p>
<p>Returns the typical error for each eigenvalue in a
<tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p>The method of North et al. (1982) is used to compute the typical
error for each eigenvalue. It is assumed that the number of
times in the input data set is the same as the number of
independent realizations. If this assumption is not valid then
the result may be inappropriate.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>The number of eigenvalues to return typical errors for.
Defaults to typical errors for all eigenvalues.</dd>
<dt><em>vfscaled</em></dt>
<dd>If <em>True</em> scale the errors by the sum of the eigenvalues.
This yields typical errors with the same scale as the
values returned by the
<a class="reference internal" href="#eof2.Eof.varianceFraction" title="eof2.Eof.varianceFraction"><tt class="xref py py-meth docutils literal"><span class="pre">varianceFraction()</span></tt></a> method. If <em>False</em>
then no scaling is done. Defaults to <em>False</em> (no scaling).</dd>
</dl>
<p><strong>References</strong></p>
<p>North, G. R., T. L. Bell, R. F. Cahalan, and F. J. Moeng, 1982:
&#8220;Sampling errors in the estimation of empirical orthogonal
functions&#8221;, <em>Monthly Weather Review</em>, <strong>110</strong>, pages 669-706.</p>
<p><strong>Examples:</strong></p>
<p>Typical errors for all eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">errs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">northTest</span><span class="p">()</span>
</pre></div>
</div>
<p>Typical errors for the first 3 eigenvalues scaled by the sum of
the eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">errs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">northTest</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">vfscaled</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.pcs">
<tt class="descname">pcs</tt><big>(</big><em>pcscaling=0</em>, <em>npcs=None</em><big>)</big><a class="headerlink" href="#eof2.Eof.pcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal component time series (PCs).</p>
<p>Returns the ordered PCs in a a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the retrieved PCs. The following
values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled principal components (default).</li>
<li><em>1</em> : Principal components are scaled to unit variance
(divided by the square-root of their eigenvalue).</li>
<li><em>2</em> : Principal components are multiplied by the
square-root of their eigenvalue.</li>
</ul>
</dd>
<dt><em>npcs</em> <span class="classifier-delimiter">:</span> <span class="classifier">Number of principal components to retrieve. Defaults to</span></dt>
<dd>all the principal components.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>All un-scaled PCs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">pcs</span><span class="p">()</span>
</pre></div>
</div>
<p>First 3 PCs scaled to unit variance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">pcs</span><span class="p">(</span><span class="n">npcs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pcscaling</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.projectField">
<tt class="descname">projectField</tt><big>(</big><em>field</em>, <em>neofs=None</em>, <em>eofscaling=0</em>, <em>weighted=True</em><big>)</big><a class="headerlink" href="#eof2.Eof.projectField" title="Permalink to this definition">¶</a></dt>
<dd><p>Project a field onto the EOFs.</p>
<p>Returns projected time series in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p>Given a field, projects it onto the EOFs to generate a
corresponding set of time series in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.
The field can be projected onto all the EOFs or just a subset.
The field must have the same corresponding spatial dimensions
(including missing values in the same places) as the original
input to the <a class="reference internal" href="#eof2.Eof" title="eof2.Eof"><tt class="xref py py-class docutils literal"><span class="pre">Eof</span></tt></a> instance. The field may have
a different length time dimension to the original input field
(or no time dimension at all).</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>field</em></dt>
<dd>A field (<tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable) to project onto the EOFs.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to project onto. Defaults to all EOFs.</dd>
<dt><em>eofscaling</em></dt>
<dd><p class="first">Set the scaling of the EOFs that are projected
onto. The following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their eigenvalue.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
<dt><em>weighted</em></dt>
<dd>If <em>True</em> then the EOFs are weighted prior to projection. If
<em>False</em> then no weighting is applied. Defaults to <em>True</em>
(weighting is applied). Generally only the default setting
should be used.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>Project a field onto all EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">projectField</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
</pre></div>
</div>
<p>Project fields onto the three leading EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">projectField</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">neofs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.reconstructedField">
<tt class="descname">reconstructedField</tt><big>(</big><em>neofs</em><big>)</big><a class="headerlink" href="#eof2.Eof.reconstructedField" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructed data field based on a subset of EOFs.</p>
<p>If weights were passed to the <a class="reference internal" href="#eof2.Eof" title="eof2.Eof"><tt class="xref py py-class docutils literal"><span class="pre">Eof</span></tt></a> instance
then the returned reconstructed field will be automatically
un-weighted. Otherwise the returned reconstructed field will
be weighted in the same manner as the input to the
<a class="reference internal" href="#eof2.Eof" title="eof2.Eof"><tt class="xref py py-class docutils literal"><span class="pre">Eof</span></tt></a> instance.</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to use for the reconstruction.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>Reconstruct the input field using 3 EOFs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rfield</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">reconstructedField</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.totalAnomalyVariance">
<tt class="descname">totalAnomalyVariance</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.Eof.totalAnomalyVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Total variance associated with the field of anomalies (the sum
of the eigenvalues).</p>
<p>Returns a scalar (not a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> transient variable).</p>
<p><strong>Examples:</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">totalAnomalyVariance</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.Eof.varianceFraction">
<tt class="descname">varianceFraction</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.Eof.varianceFraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional EOF variances.</p>
<p>The fraction of the total variance explained by each EOF, a
value between 0 and 1 inclusive, in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return the fractional variance for.
Defaults to all eigenvalues.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>The fractional variance represented by each eigenvalue:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">varfrac</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">varianceFraction</span><span class="p">()</span>
</pre></div>
</div>
<p>The fractional variance represented by the first 3 eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">varfrac</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">VarianceFraction</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="eof2.MultipleEof">
<em class="property">class </em><tt class="descclassname">eof2.</tt><tt class="descname">MultipleEof</tt><big>(</big><em>*datasets</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiple EOF analysis (meta-data enabled <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> interface).</p>
<p>Create a MultipleEof object.</p>
<p>The EOF solution is computed at initialization time. Method
calls are used to retrieve computed quantities.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt><em>*datasets</em></dt>
<dd>One or more <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variables containing the data to
be analyzed. Time must be the first dimension of each
variable. Missing values are allowed provided that they are
constant with time (e.g., values of an oceanographic field
over land).</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>weights</em></dt>
<dd><p class="first">Sets the weighting method. The following values are
accepted:</p>
<ul class="simple">
<li><em>&#8220;area&#8221;</em> : Square-root of grid cell area normalized by
total area. Requires a latitude-longitude grid to be
present in the corresponding <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable
in <em>*datasets</em>. This is a fairly standard weighting
strategy. If you are unsure which method to use and you
have gridded data then this should be your first choice.</li>
<li><em>&#8220;coslat&#8221;</em> : Square-root of cosine of latitude
(<em>&#8220;cos_lat&#8221;</em> is also accepted). Requires a latitude
dimension to be present in the corresponding
<tt class="xref py py-mod docutils literal"><span class="pre">cmds2</span></tt> variable in <em>*datasets</em>.</li>
<li><em>&#8220;none&#8221;</em> : Equal weights for all grid points (default).</li>
<li><em>None</em> : Same as <em>&#8220;none&#8221;</em>.</li>
</ul>
<blockquote class="last">
<div>A sequence of values may be passed to use different
weighting for each data set. Arrays of weights may also
be supplied instead of specifying a weighting method.</div></blockquote>
</dd>
<dt><em>center</em></dt>
<dd>If <em>True</em>, the mean along the first axis of the input data
sets (the time-mean) will be removed prior to analysis. If
<em>False</em>, the mean along the first axis will not be removed.
Defaults to <em>True</em> (mean is removed). Generally this option
should be set to <em>True</em> as the covariance interpretation
relies on input data being anomalies with a time-mean of 0.
A valid reson for turning this off would be if you have
already generated an anomaly data set. Setting to <em>True</em> has
the useful side-effect of propagating missing values along
the time-dimension, ensuring the solver will work even if
missing values occur at different locations at different
times.</dd>
<dt><em>ddof</em></dt>
<dd>&#8216;Delta degrees of freedom&#8217;. The divisor used to normalize
the covariance matrix is <em>N - ddof</em> where <em>N</em> is the
number of samples. Defaults to <em>1</em>.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>EOF analysis with area-weighting using two input fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">eof2</span> <span class="kn">import</span> <span class="n">Eof</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eofobj</span> <span class="o">=</span> <span class="n">Eof</span><span class="p">(</span><span class="n">field_a</span><span class="p">,</span> <span class="n">field_b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s">&quot;area&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="eof2.MultipleEof.eigenvalues">
<tt class="descname">eigenvalues</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues (decreasing variances) associated with each EOF.</p>
<p>Returns the ordered eigenvalues in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return. Defaults to all
eigenvalues.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>All eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lambdas</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
</pre></div>
</div>
<p>The first eigenvalue:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lambda1</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.eofs">
<tt class="descname">eofs</tt><big>(</big><em>eofscaling=0</em>, <em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.eofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Empirical orthogonal functions (EOFs).</p>
<p>Returns the ordered EOFs in <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variables.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>eofscaling</em></dt>
<dd><p class="first">Sets the scaling of the EOFs. The following values are
accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their
eigenvalues.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalues.</li>
</ul>
</dd>
</dl>
<p><em>neofs</em> &#8211; Number of EOFs to return. Defaults to all EOFs.</p>
<p><strong>Examples:</strong></p>
<p>All EOFs with no scaling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs_a</span><span class="p">,</span> <span class="n">eofs_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofs</span><span class="p">()</span>
</pre></div>
</div>
<p>First 3 EOFs with scaling applied:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs_a</span><span class="p">,</span> <span class="n">eofs_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofs</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">eofscaling</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.eofsAsCorrelation">
<tt class="descname">eofsAsCorrelation</tt><big>(</big><em>neofs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.eofsAsCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the correlation of the PCs with the original
field.</p>
<p>Returns the ordered correlation EOFs in <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt>
variables.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
</dl>
<p><strong>Note:</strong></p>
<p>These are only the EOFs expressed as correlation and are not
related to EOFs computed using the correlation matrix.</p>
<p><strong>Examples:</strong></p>
<p>All EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs_a</span><span class="p">,</span> <span class="n">eofs_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCorrelation</span><span class="p">()</span>
</pre></div>
</div>
<p>The leading EOF:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eof1_a</span><span class="p">,</span> <span class="n">eof1_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCorrelation</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.eofsAsCovariance">
<tt class="descname">eofsAsCovariance</tt><big>(</big><em>neofs=None</em>, <em>pcscaling=1</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.eofsAsCovariance" title="Permalink to this definition">¶</a></dt>
<dd><p>EOFs scaled as the covariance of the PCs with the original
field.</p>
<p>Returns the ordered covariance EOFs in <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt>
variables.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to return. Defaults to all EOFs.</dd>
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the PCs used to compute covariance. The
following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled PCs.</li>
<li><em>1</em> : PCs are scaled to unit variance (divided by the
square-root of their eigenvalue) (default).</li>
<li><em>2</em> : PCs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>All EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eofs_a</span><span class="p">,</span> <span class="n">eofs_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">()</span>
</pre></div>
</div>
<p>The leading EOF:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eof1_a</span><span class="p">,</span> <span class="n">eof1_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The leading EOF using un-scaled PCs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eof1_a</span><span class="p">,</span> <span class="n">eof1_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">eofsAsCovariance</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pcscaling</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.northTest">
<tt class="descname">northTest</tt><big>(</big><em>neigs=None</em>, <em>vfscaled=False</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.northTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Typical errors for eigenvalues.</p>
<p>Returns the typical error for each eigenvalue in a
<tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p>The method of North et al. (1982) is used to compute the typical
error for each eigenvalue. It is assumed that the number of
times in the input data set is the same as the number of
independent realizations. If this assumption is not valid then
the result may be inappropriate.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>The number of eigenvalues to return typical errors for.
Defaults to typical errors for all eigenvalues.</dd>
<dt><em>vfscaled</em></dt>
<dd>If <em>True</em> scale the errors by the sum of the eigenvalues.
This yields typical errors with the same scale as the
values returned by the
<a class="reference internal" href="#eof2.MultipleEof.varianceFraction" title="eof2.MultipleEof.varianceFraction"><tt class="xref py py-meth docutils literal"><span class="pre">varianceFraction()</span></tt></a> method.
If <em>False</em> then no scaling is done. Defaults to <em>False</em> (no
scaling).</dd>
</dl>
<p><strong>References</strong></p>
<p>North, G. R., T. L. Bell, R. F. Cahalan, and F. J. Moeng, 1982:
&#8220;Sampling errors in the estimation of empirical orthogonal
functions&#8221;, <em>Monthly Weather Review</em>, <strong>110</strong>, pages 669-706.</p>
<p><strong>Examples:</strong></p>
<p>Typical errors for all eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">errs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">northTest</span><span class="p">()</span>
</pre></div>
</div>
<p>Typical errors for the first 3 eigenvalues scaled by the sum of
the eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">errs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">northTest</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">vfscaled</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.pcs">
<tt class="descname">pcs</tt><big>(</big><em>pcscaling=0</em>, <em>npcs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.pcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal component time series (PCs).</p>
<p>Returns the ordered PCs in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>pcscaling</em></dt>
<dd><p class="first">Set the scaling of the retrieved PCs. The following
values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled principal components (default).</li>
<li><em>1</em> : Principal components are scaled to unit variance
(divided by the square-root of their eigenvalue).</li>
<li><em>2</em> : Principal components are multiplied by the
square-root of their eigenvalue.</li>
</ul>
</dd>
<dt><em>npcs</em> <span class="classifier-delimiter">:</span> <span class="classifier">Number of principal components to retrieve. Defaults to</span></dt>
<dd>all the principal components.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>All un-scaled PCs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">pcs</span><span class="p">()</span>
</pre></div>
</div>
<p>First 3 PCs scaled to unit variance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">pcs</span><span class="p">(</span><span class="n">npcs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pcscaling</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.projectField">
<tt class="descname">projectField</tt><big>(</big><em>*fields</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.projectField" title="Permalink to this definition">¶</a></dt>
<dd><p>Project a set of fields onto the EOFs.</p>
<p>Given a set of fields, projects them onto the EOFs to generate a
a corresponding set of time series in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.
Fields can be projected onto all the EOFs or just a subset. There
must be the same number of fields as were originally input into
the <a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a> instance, and each field
must have the same corresponding spatial dimensions (including
missing values in the same places). The fields may have a
different length time dimension to the original input fields (or
no time dimension at all).</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>*fields</em></dt>
<dd>One or more fields (<tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variables) to project
onto the EOFs. Must be the same as the number of fields used
to initialize the <a class="reference internal" href="#eof2.MultipleEofSolver" title="eof2.MultipleEofSolver"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEofSolver</span></tt></a>
instance.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to project onto. Defaults to all EOFs.</dd>
<dt><em>eofscaling</em></dt>
<dd><p class="first">Set the scaling of the EOFs that are projected
onto. The following values are accepted:</p>
<ul class="last simple">
<li><em>0</em> : Un-scaled EOFs (default).</li>
<li><em>1</em> : EOFs are divided by the square-root of their eigenvalue.</li>
<li><em>2</em> : EOFs are multiplied by the square-root of their
eigenvalue.</li>
</ul>
</dd>
<dt><em>weighted</em></dt>
<dd>If <em>True</em> then the EOFs are weighted prior to projection. If
<em>False</em> then no weighting is applied. Defaults to <em>True</em>
(weighting is applied). Generally only the default setting
should be used.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>Project fields onto all EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">projectField</span><span class="p">(</span><span class="n">field_c</span><span class="p">,</span> <span class="n">field_d</span><span class="p">)</span>
</pre></div>
</div>
<p>Project fields onto the three leading EOFs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pcs</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">projectField</span><span class="p">(</span><span class="n">field_c</span><span class="p">,</span> <span class="n">field_c</span><span class="p">,</span> <span class="n">neofs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.reconstructedField">
<tt class="descname">reconstructedField</tt><big>(</big><em>neofs</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.reconstructedField" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructed data field based on a subset of EOFs.</p>
<p>If weights were passed to the <a class="reference internal" href="#eof2.MultipleEof" title="eof2.MultipleEof"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEof</span></tt></a>
instance then the returned reconstructed fields will be
automatically un-weighted. Otherwise the returned reconstructed
field will  be weighted in the same manner as the input to the
<a class="reference internal" href="#eof2.MultipleEof" title="eof2.MultipleEof"><tt class="xref py py-class docutils literal"><span class="pre">MultipleEof</span></tt></a> instance.</p>
<p><strong>Argument:</strong></p>
<dl class="docutils">
<dt><em>neofs</em></dt>
<dd>Number of EOFs to use for the reconstruction.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>Reconstruct the input fields using 3 EOFs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rfield_a</span><span class="p">,</span> <span class="n">rfield_b</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">reconstructedField</span><span class="p">(</span><span class="n">neofs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.totalAnomalyVariance">
<tt class="descname">totalAnomalyVariance</tt><big>(</big><big>)</big><a class="headerlink" href="#eof2.MultipleEof.totalAnomalyVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Total variance associated with the field of anomalies (the sum
of the eigenvalues).</p>
<p>Returns a scalar (not a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable).</p>
<p><strong>Examples:</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">totalAnomalyVariance</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="eof2.MultipleEof.varianceFraction">
<tt class="descname">varianceFraction</tt><big>(</big><em>neigs=None</em><big>)</big><a class="headerlink" href="#eof2.MultipleEof.varianceFraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional EOF variances.</p>
<p>The fraction of the total variance explained by each EOF, a
value between 0 and 1 inclusive, in a <tt class="xref py py-mod docutils literal"><span class="pre">cdms2</span></tt> variable.</p>
<p><strong>Optional argument:</strong></p>
<dl class="docutils">
<dt><em>neigs</em></dt>
<dd>Number of eigenvalues to return the fractional variance for.
Defaults to all eigenvalues.</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>The fractional variance represented by each eigenvalue:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">varfrac</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">varianceFraction</span><span class="p">()</span>
</pre></div>
</div>
<p>The fractional variance represented by the first 3 eigenvalues:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">varfrac</span> <span class="o">=</span> <span class="n">eofobj</span><span class="o">.</span><span class="n">VarianceFraction</span><span class="p">(</span><span class="n">neigs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3>Table Of Contents</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="pexsst.html">Practical Example: Sea Surface Temperature (ENSO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="refwrap.html">Metadata-Enabled Interface Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="refsolve.html">Non-metadata Interface Reference</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Full API Reference</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="refsolve.html"
                        title="previous chapter">Non-metadata Interface Reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="refsolve.html" title="Non-metadata Interface Reference"
             >previous</a> |</li>
        <li><a href="index.html">eof2 1.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Andrew Dawson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>